## 싱글톤 레지스트리와 오브젝트 스코프

### 오브젝트의 동일성과 동등성

- 두 개의 오브젝트가 동일하다면 (동일성) 하나의 오브젝트만 존재하고, 두개의 오브젝트는 레퍼런스 변수만 갖고 있음 = 두 레퍼런스가 같은 객체(메모리의 주소)를 가리킬 때
- 두 개의 오브젝트가 동일하지는 않지만 동등할 경우 (동등성) 각기 다른 오브젝트가 메모리상 존재함 = 객체는 다르지만 내부 데이터가 같은 경우
- 애플리케이션 컨텍스트에서 등록된 빈을 getBean() 두 번 했을 때 가져온 오브젝트가 동일함

### 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리임

- 스프링은 내부에 생성하는 빈 오브젝트를 모두 싱글톤으로 만듬
- 왜 싱글톤으로 만듬 ? 스프링이 주로 적용하는 대상은 자바 엔터프라이즈 기술을 사용하는 서버 기술이기 때문 → 매번 클라이언트 요청이 올 때마다 오브젝트를 매번 생성해 사용한다면 서버에 부하가 감
- 서블릿은 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝트라고 할 수 있음
  - 서블릿은 클라이언트 요청을 받아 처리하고 그에 대한 응답을 만드는 자바 기반의 서버 측 프로그램임 (웹 서버에서 실행되는 자바 객체)
  - 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작함 = 여러 스레드에서 하나의 오브젝트를 공유

### 자바에서 싱글톤 구현 방법

- 클래스 밖으로 오브젝트를 생성하지 못하도록 생성자 private으로 만듬
- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드 정의
- 스태틱 팩토리 메소드인 getInstance를 만듬

### 싱글톤 패턴의 한계

- private 생성자를 갖고 있기 때문에 상속할 수 없음
  - 객체지향적인 설계의 장점을 적용하기 어려움
- 테스트하기가 힘듬
  - 일반적으로 테스트에서는 Mock 객체를 주입해 테스트 용이성을 높임
  - 싱글톤은 내부에 의존 객체가 고정되어 있거나 생성자 주입이 불가능해 테스트 어려움
- 서버 환경에서는 싱글톤이 하나만 만들어지는것을 보장하지 못함
  - 클래스 로더가 여러개 존재하는 경우 서로 다른 싱글톤 인스턴스가 생성될 수 있음
  - 클래스로더란 자바 바이트 코드를 jvm 메모리 영역에 로드해서 사용할 수 있도록 만드는 역할임
  - 멀티 JVM 환경일 경우 서버마다 하나씩 싱글톤 객체가 생성됨
- 전역상태를 만들 수 있기 때문에 바람직하지 못함
  - 아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 전역상태를 갖는것은 객체지향 프로그래밍에서는 권장되지 않음

### 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공함

- 평범한 자바 클래스도 IoC 컨테이너에게 제어권을넘기면 싱글톤 방식으로 관리할 수 있음
- public 생성자를 가질 수 있음
- 고전적인 싱글톤 패턴을 대신해서 싱글톤을 만들고 관리해줌

### 싱글톤으로 만들어지기 때문에 주의할 점

- 멀티스레드 환경이라면 여러 스레드가 접근하여 사용할 수 있어 상태 관리에 신경써야함
- 상태 정보를 내부에 갖고 있지 않은 무상태 방식으로 만들어져야함
- 요청에 따른 정보(DB 조회 결과, 사용자 입력 등)는 메서드의 파라미터, 로컬 변수, 리턴값으로만 처리한다.
- 싱글톤 객체라도, 메서드 파라미터나 지역 변수는 각 스레드마다 별도의 메모리 공간이 생성되므로 충돌이 없다.
- 스프링이 한 번 초기화해주고 이후 수정되지 않는 인스턴스나 읽기 전용이라면 인스턴스 변수로 사용해도 괜찮음

### 스프링 빈 스코프

- 빈의 스코프 : 빈이 생성되고, 존재하고, 적용되는 범위
- 기본 스코프는 싱글톤임
- 프로토 타입 스코프 : 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어줌
- 요청 스코프 : 웹을 통해 새로운 HTTP 요청이 생길 때마다 생성됨

### 자문자답

- 멀티 모듈과 클래스 로더는 같은 개념인가?
  - X , 멀티모듈은 개발과 빌드 시점에서의 구조를 의미하고, 클래스 로더는 JVM이 실행되는 시점에서 .class 파일을 메모리에 로딩하는 메커니즘임
- 멀티모듈이면 클래스 로더도 여러 개인가?
  - X , 보통 하나의 .jar 또는 .war로 묶여 배포되기 때문에 클래스 로더는 하나로 동작함
- 클래스 로더가 여러 개인 경우는 언제인가?
  - 톰캣 같은 WAS에서 .war 파일마다 별도의 클래스 로더를 사용해 애플리케이션을 격리할 때
  - war파일 : 웹 애플리케이션을 배포할 수 있는 압축된 형태의 파일 , 전통적인 스프링은 war+톰캣
  - 스프링부트는 내장 톰캣을 통해 jar파일만으로도 실행 가능함 , 일반적으로 클래스 로더 1개
- 클래스 로더가 다르면 어떤 문제가 생기나?
  - 같은 클래스라도 서로 다른 클래스로 인식 → 싱글톤 깨지거나 ClassCastException 등 발생 가능
- 멀티모듈 구조가 클래스 로더 수에 영향을 주는가?
  - 클래스 로더 수는 실행 환경(WAS 등)에 따라 결정됨, 멀티모듈 여부와는 무관
- 스프링은 왜 싱글톤으로 객체를 관리할 수 있나?
  - IoC 컨테이너가 객체 생명주기를 관리하며, Bean을 한 번만 생성해서 캐싱하기 때문

## 싱글톤 레지스트리와 오브젝트 스코프

### 오브젝트의 동일성과 동등성

- 두 개의 오브젝트가 동일하다면 (동일성) 하나의 오브젝트만 존재하고, 두개의 오브젝트는 레퍼런스 변수만 갖고 있음 = 두 레퍼런스가 같은 객체(메모리의 주소)를 가리킬 때
- 두 개의 오브젝트가 동일하지는 않지만 동등할 경우 (동등성) 각기 다른 오브젝트가 메모리상 존재함 = 객체는 다르지만 내부 데이터가 같은 경우
- 애플리케이션 컨텍스트에서 등록된 빈을 getBean() 두 번 했을 때 가져온 오브젝트가 동일함

### 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리임

- 스프링은 내부에 생성하는 빈 오브젝트를 모두 싱글톤으로 만듬
- 왜 싱글톤으로 만듬 ? 스프링이 주로 적용하는 대상은 자바 엔터프라이즈 기술을 사용하는 서버 기술이기 때문 → 매번 클라이언트 요청이 올 때마다 오브젝트를 매번 생성해 사용한다면 서버에 부하가 감
- 서블릿은 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝트라고 할 수 있음
  - 서블릿은 클라이언트 요청을 받아 처리하고 그에 대한 응답을 만드는 자바 기반의 서버 측 프로그램임 (웹 서버에서 실행되는 자바 객체)
  - 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작함 = 여러 스레드에서 하나의 오브젝트를 공유

### 자바에서 싱글톤 구현 방법

- 클래스 밖으로 오브젝트를 생성하지 못하도록 생성자 private으로 만듬
- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드 정의
- 스태틱 팩토리 메소드인 getInstance를 만듬

### 싱글톤 패턴의 한계

- private 생성자를 갖고 있기 때문에 상속할 수 없음
  - 객체지향적인 설계의 장점을 적용하기 어려움
- 테스트하기가 힘듬
  - 일반적으로 테스트에서는 Mock 객체를 주입해 테스트 용이성을 높임
  - 싱글톤은 내부에 의존 객체가 고정되어 있거나 생성자 주입이 불가능해 테스트 어려움
- 서버 환경에서는 싱글톤이 하나만 만들어지는것을 보장하지 못함
  - 클래스 로더가 여러개 존재하는 경우 서로 다른 싱글톤 인스턴스가 생성될 수 있음
  - 클래스로더란 자바 바이트 코드를 jvm 메모리 영역에 로드해서 사용할 수 있도록 만드는 역할임
  - 멀티 JVM 환경일 경우 서버마다 하나씩 싱글톤 객체가 생성됨
- 전역상태를 만들 수 있기 때문에 바람직하지 못함
  - 아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 전역상태를 갖는것은 객체지향 프로그래밍에서는 권장되지 않음

### 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공함

- 평범한 자바 클래스도 IoC 컨테이너에게 제어권을넘기면 싱글톤 방식으로 관리할 수 있음
- public 생성자를 가질 수 있음
- 고전적인 싱글톤 패턴을 대신해서 싱글톤을 만들고 관리해줌

### 싱글톤으로 만들어지기 때문에 주의할 점

- 멀티스레드 환경이라면 여러 스레드가 접근하여 사용할 수 있어 상태 관리에 신경써야함
- 상태 정보를 내부에 갖고 있지 않은 무상태 방식으로 만들어져야함
- 요청에 따른 정보(DB 조회 결과, 사용자 입력 등)는 메서드의 파라미터, 로컬 변수, 리턴값으로만 처리한다.
- 싱글톤 객체라도, 메서드 파라미터나 지역 변수는 각 스레드마다 별도의 메모리 공간이 생성되므로 충돌이 없다.
- 스프링이 한 번 초기화해주고 이후 수정되지 않는 인스턴스나 읽기 전용이라면 인스턴스 변수로 사용해도 괜찮음

### 스프링 빈 스코프

- 빈의 스코프 : 빈이 생성되고, 존재하고, 적용되는 범위
- 기본 스코프는 싱글톤임
- 프로토 타입 스코프 : 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어줌
- 요청 스코프 : 웹을 통해 새로운 HTTP 요청이 생길 때마다 생성됨

### 자문자답

- 멀티 모듈과 클래스 로더는 같은 개념인가?
  - X , 멀티모듈은 개발과 빌드 시점에서의 구조를 의미하고, 클래스 로더는 JVM이 실행되는 시점에서 .class 파일을 메모리에 로딩하는 메커니즘임
- 멀티모듈이면 클래스 로더도 여러 개인가?
  - X , 보통 하나의 .jar 또는 .war로 묶여 배포되기 때문에 클래스 로더는 하나로 동작함
- 클래스 로더가 여러 개인 경우는 언제인가?
  - 톰캣 같은 WAS에서 .war 파일마다 별도의 클래스 로더를 사용해 애플리케이션을 격리할 때
  - war파일 : 웹 애플리케이션을 배포할 수 있는 압축된 형태의 파일 , 전통적인 스프링은 war+톰캣
  - 스프링부트는 내장 톰캣을 통해 jar파일만으로도 실행 가능함 , 일반적으로 클래스 로더 1개
- 클래스 로더가 다르면 어떤 문제가 생기나?
  - 같은 클래스라도 서로 다른 클래스로 인식 → 싱글톤 깨지거나 ClassCastException 등 발생 가능
- 멀티모듈 구조가 클래스 로더 수에 영향을 주는가?
  - 클래스 로더 수는 실행 환경(WAS 등)에 따라 결정됨, 멀티모듈 여부와는 무관
- 스프링은 왜 싱글톤으로 객체를 관리할 수 있나?
  - IoC 컨테이너가 객체 생명주기를 관리하며, Bean을 한 번만 생성해서 캐싱하기 때문

## 의존 관계 주입 (DI)

### 스프링 IoC의 핵심은 의존 관계 주입이다.

- 의존관계란?
  - A가 B에 의존하고 있다는것은 B가 변하면 A에 영향을 미친다는 뜻
  - 의존관계에는 방향성이 있음 . 반대로 B가 A에 의존하지 않음 = A가 변해도 B는 영향을 받지 않음
- 인터페이스에 대하서만 의존관계를 만들어주면 느슨한 의존관계를 가짐
  - 설계할 때는 인터페이스만 보고 어떤 구현체가 들어올지 실행 중 결정
  - 런타임 시에 의존관계를 맺는 대상을 의존 오브젝트라고함
- 의존 관계 주입은 3가지 조건을 충족하는 작업을 말함
  - 클래스 모델이나 코드에는 런타임 시전의 의존관계가 드러나지않음 (인터페이스에 의존하고 있어야함)
  - 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정함
  - 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입) 해줌으로써 만들어짐
- 의존관계 주입의 핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제 3의 존재가 있음

### 의존 관계 검색과 주입

- 의존 관계 검색은 의존관계를 맺는 방법이 외부로부터 주입이 아니라 스스로 검색을 이용하는 방식임
- 검색은 런타임 시점 시 의존관계를 맺을 오브젝트를 결정하는것과 오브젝트 생성은 IoC에게 맞기지만, 이를 가져올 때는 주입 대신 스스로 컨테이너에게 요청하는 방법 사용
- context.getBean()을 통해 직접 검색해서 꺼내씀
- 의존 객체를 검색하는 로직과 비즈니스 로직이 한곳에 섞여 있으면 어색해 대개는 의존관계 주입 방식 사용함
- 의존 관계 검색 방식은 검색하는 오브젝트는 자신이 스프링의 빈일 필요가 없음
- 의존 관계 주입 방식은 DI를 원하는 오브젝트는 자기 자신이 컨테이너가 관리되어야하는 빈이 돼야함

### 의존 관계 주입의 장점과 응용

- 코드에는 구체 클래스에 대한 의존이 드러나지 않음
  - 코드 상에는 인터페이스나 추상 타입만 참조하므로, 실제 어떤 구현 클래스가 사용될지는 런타임에 결정됨
- 인터페이스 기반 설계로 결합도를 낮출 수 있음
  - 클래스간 강한 결합은 피하고, 변경에 유연한 구조가 됨
- 다른 책임을 가진 사용 의존관계가 있는 대상이 바뀌거나 변경되더라도 자신은 영향을 받지 않음
  - 다른 구현체로 교체해도 의존 주입만 바꾸면 되므로, 클라이언트 코드 수정 없이 기능을 확장하거나 테스트 가능
- 변경을 통한 다양한 다양한 확장 방법
  - 실체 구현체 대신 Mock, Stub 등 테스트 용 객체를 주입해 단위 테스트가 용이함
- 기능 구현의 교환
  - 같은 인터페이스를 구현한 객체를 용도나 상황에 맞게 자유롭게 교체할 수 있는 구조
- 부가 기능 추가
  - 핵심 로직을 바꾸지 않고, 그 앞뒤로 기능을 끼워넣을 수 있음
  - 주입할 때 구현체만 변경함

### 메소드를 이용한 의존관계 주입

- 수정자 메소드를 이용한 주입

```java
public class UserDao{
	private ConnectionMaker connectionMaker;
	public void setConnectionMaker(ConnectionMaker connectionMaker){
		this.connectionMaker = connectionMaker;
	}
}
```

### 자문 자답

- 런타임 시점의 의존관계란?
  - 컴파일 시점에는 어떤 구현체가 주입되는지 알 수 없고 실제 어떤 객체가 들어올지는 프로그램이 실행될 때 (런타임)에 결정되는것
- 컴파일 시점의 의존성과 런타임 시점의 의존성(DI)이란?
  - 컴파일 시점 :new DConnectionMaker() 직접 생성 ( 컴파일 시점에서 컴파일러가 이 클래스는 DConnectionMaker를 쓴다고 알고 있음!)
  - 런타임 시점 : 인터페이스 기반, 외부 주입, 컴파일러는 어떤 구현체가 들어오는지 모르고 실행시점(런타임)에서 주입되어 결정됨
- 런타임 시점의 의존성 주입 장점이 코드를 고치지 않고도 동작을 바꿀 수 있다는데 어차피 런타임 시점에서 설정도 코드를 고쳐야하지 않나..?
  - 포인트는 어디를 고치느냐임
  - 컴파일 시점 의존성은 구현체를 코드안에서 직접 생성 new하므로 구현체가 바뀌면 비즈니스 로직 코드 자체도 수정해야함 이는 결합도를 높임
    - OCP 위배 : 새로운 기능이나 구현체를 추가할 때 기존 클래스를 수정해야함
    - 유연한 확장 어려움 : 이메일알림 → 문자알림으로 변경하려면 서비스 클래스 전체를 수정해야함
  - 런타임 시점의 의존성은 비즈니스 로직 코드는 인터페이스에만 의존하므로 구현체를 바꿔도 비즈니스 로직에는 손을 안대도됨
- 런타임 관계를 맺어준다는 뜻은?
  - 의존 객체를 내가 new하지 않고 외부에서 생성하고 주입해준다는 의미
- 인터페이스로 관계맺으면 왜 결합도가 낮아지는지?
  - 코드는 구현체가 아니라 인터페이스에 의존하기 때문에 구현체가 바뀌어도 코드 수정없이 교체할 수 있기 때문임
- 자기 자신이 컨테이너에 관리되어야하는빈???

  - 스프링에서 의존객체를 주입하려면 그 대상(받는쪽)도 스프링이 관리하는 빈이어야함

  ```java
  @Component
  public class MyService { //myservice가 스프링 빈이어야함
      @Autowired
      private UserDao userDao; // DI 받음
  }
  ```

  ## 정리

1. 책임이 다른 두 코드를 분리해서 두 개의 클래스로 만들었다. (관심사의 분리, 리팩토링)
2. 바뀔 수 있는 쪽의 클래스는 인터페이스를 구현하도록하고, 다른 클래스는 인터페이스를 통해 접근하도록 변경하였다.
   1. 인터페이스를 정의한 쪽의 구현 방법이 달라져도 그 기능을 사용하는 클래스의 코드는 같이 수정할 필요가 없도록 만들었다.(전략패턴)
   2. 자신의 책임 자체가 변경되는 경우 외에는 불필요한 변화가 발생하지 않도록 막아주고 , 자신이 사용하는 외부 오브젝트 기능은 자유롭게 확장하거나 변경하도록 만들었다.(OCP)
   3. 한쪽의 기능 변하가 다른 쪽의 변경을 요구하지 않아도 되게 했다. (낮은 결합도)
   4. 자신의 책임과 관심사에만 순수하게 집중하는 코드를 만들었다. (높은 응집도)
3. 오브젝트가 생성되고 여타 오브젝트와 관계를 맺는 작업의 제어권을 별도의 오브젝트 팩토리로 만들어 넘겼다. (IoC)
4. 전통적인 싱글톤 패턴 구현 방식에 대해 살펴보고, 싱글톤 패턴의 단점을 극복할 수 있도록 설계된 컨테이너를 활용하는법을 배웠다.(싱글톤 레지스트리)
5. 설계 시점과 코드에는 느슨한 의존관계만 만들어놓고 런타임 시에 실제 사용할 구체적인 의존 오브젝트를 제 3자의 도움을 받아서 의존관계를 갖게해주는 IoC의 케이스에 대해 배웠다.(의존 관계 주입)
