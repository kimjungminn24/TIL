### CPU 스케줄링이 필요한 이유

- CPU는 한 번에 하나의 작업만 처리할 수 있음→ 여러개의 프로세스가 동시에 존재해 누구에게 cpu를 줄지 선택이 필요함
- CPU 자원을 효율적으로 활용하기 위해 → 어떤 프로세스는 CPU를 쓰고 어떤 프로세스는 I/O 작업 중이면 CPU가 놀지 않도록 레디큐에 있는 다른 프로세스를 배치해야함
- 멀티 프로그래밍 시스템에서 경쟁이 발생함 → 여러 프로세스가 동시에 메모리에 올라와 있고 CPU자원을 서로 경쟁해 OS가 스케줄러를 통해 공정하게 분배해야함

### CPU 스케줄링이 발생할 수 있는 4가지 상황

- Running → Waiting (입출력 등으로 CPU 반납)
    - 프로세스가 실행 중인데 I/O 요청 등의 이유로 스스로 CPU를 내려놓고 대기 상태(waiting)로 감
    - 이미 CPU를 반납했기 때문에, OS는 다른 프로세스를 선택하면 됨 → 강제할 필요 없음 (비선점, non-preemptive)
- Running → Ready (선점형 스케줄링 가능)
    - 실행 중인 프로세스가 CPU를 쓰고 있는데, 타이머 인터럽트나 더 높은 우선순위 프로세스 등장 등으로 인해 준비 상태로 밀려남
    - 선점형(preemptive)일 경우, OS가 현재 프로세스를 멈추고 다른 프로세스를 실행할 수 있음(비선점형이라면 그냥 계속 진행)
- Waiting → Ready (I/O 끝나고 준비 상태로 전환)
    - I/O가 끝나고 다시 CPU를 쓸 준비가 된 상태로 돌아옴
    - 선점형이면, 지금 실행 중인 프로세스보다 우선순위가 높을 경우 바로 CPU를 빼앗을 수 있음 비선점형이면 끝날 때까지 기다림
- Running → Terminate (작업 완료)
    - 프로세스가 자신의 작업을 모두 마치고 종료 상태로 이동
    - CPU를 자연스럽게 반환하므로 OS는 다음 프로세스를 고르면 됨 → 비선점형

### Dispatcher

- 스케줄러가 선택한 프로세스를 실제로 CPU에 할당하는 운영체제 구성 요소(모듈)
- Context Switching을 함 : 이전 프로세스 상태를 저장하고 새 프로세스의 상태 복구
- 사용자 모드로 전환함 : 커널 모드에서 사용자 모드로 전환해 사용자 프로세스 실행
- 프로세서에게 제어권을 넘김 : CPU가 새 프로세스를 실행하도록 제어를 전달
- 스케줄러가 실행할 프로세스를 고름 (선택) → 디스패처가 선택된 프로세스를 실제로 CPU에 할당함
- 디스패치 지연 시간 : 디스패처가 일을 시작하고 실제로 프로세스가 CPU를 받기까지 걸리는 시간 (짧을 수록 좋음)
- vmstat 명령어로 context swtich가 얼마나 자주 일어나는지 확인할 수 있음

### 스케줄링 목표

- CPU utilization : CPU가 일을 하고 있는 시간을 최대화  (CPU가 놀지 않게함)
- Throughput : 단위 시간당 완료된 프로세스 수를 최대화 (처리량 늘림)
- Turnaround time : 한 프로세스가 제출되어 완전히 끝날 때까지 걸린 시간 최소화 (전체 소요시간 줄이기)
- Waiting time : 레디 큐에서 기다린 시간의 총합 최소화 (대기 시간 줄이기)
- Response time : 요청 후 CPU를 받기까지 걸린 시간 최소화 (반응 빠르게 )

### FCFS

- 가장 먼저 도착한 프로세스부터 처리
- 비선점형
- 만약 하나의 CPU-bound 프로세스(계속 계산만 하며 CPU를 오래 점유함)와 여러 개의 I/O-bound 프로세스(짧게 CPU를 사용하고 곧바로 I/O 작업으로 빠지는 프로세스)가 있을 경우
    - FCFS 스케줄링에서는 CPU-bound 프로세스가 먼저 도착하면, 뒤에 있는 짧은 작업들이 CPU를 받지 못하고 오랜 시간 대기하게 됨
    - 이로 인해 waiting time(대기 시간)과 turnaround time(처리 시간)이 불필요하게 증가하며,
    이를 Convoy Effect(호위 효과)라고 부름

### SJF

- 가장 실행이 짧은 프로세스부터 실행
- 작업 = CPU brust  time 의미함 (CPU에서 걸리는 시간)
- 선점형일 수도 있고 비선점형일수도있음
    - 비선점형 : 새로운 프로세스가 도착해도  지금 돌고 있는 프로세스보다 짧아도 대기
    - 선점형 : 현재 실행중인 프로세스보다 남은 시간이 더 짧은 프로세스가 도착하면 CPU를 빼앗고 선점함  = SRTF (Shortest Remaining Time First)
- CPU burst time을 미리 알아야함 → 현실적으로 어려움
    - 이전 burst 시간들을 기반으로 지수 평균 방식으로 예측함
- 짧은 작업 위주로 처리되다 보니 긴 작업은 뒤로 밀려날 수 있음 → 기아 발생 가능

### SRTF

- 남은 실행 시간이 가장 짧은 프로세스부터 실행
- 새로운 프로세스가 도착했을 때 현재 실행 중인 프로세스보다 남은 시간이 짧다면 선점
- 선점형

### RR

- 프로세스에 동일한 시간 조각을 부여하고 그 시간만큼 실행 한 후 다음 프로세스로 교체
- 시간 초과된 프로세스는 레디큐 뒤로 이동
- time quantum 시간 조각은 10~100 ms사이로 설정됨
- 너무 짧으면 컨텍스트 스위칭이 자주 일어나 오버헤드 증가하고 너무 크면 FCFS와 다를 바 없어져 응답시간이 느려짐
    - CPU  burst < Time Quantum : 해당 프로세스는 타임 퀀텀이 끝나기 전에 자발적으로 종료되거나 I/O 요청을 하며 CPU반남, 컨텍스트 스위칭이 일어나고 다음 프로세스로 넘어감
    - CPU  burst > Time Quantum : 타임퀀텀이 만료되면 os가 강제로 선점하고 해당 프로세스는 레디큐 맨 뒤로 이동함

### Priority-base

- 각 프로세스에 우선순위를 부여하고 우선 순위가 높은 프로세스부터 CPU를 할당하는 방식
- SJF도 Priority base 의 한종류임 , 실행시간이 짧을수록 우선순위가 높다고 가정
- 선점형 : 실행 중인 프로세스보다 더 높은 우선순위의 프로세스가 도착하면 → 즉시선점
- 비선점형 : 현재 실행 중인 프로세스가 끝날때까지 기다림
- 기아 문제가 생김
    - 항상 우선순위가 높은 프로세스가 먼저 실행 되어 낮은 우선순위 프로세스가 계속 밀린다면 CPU를 영원히 사용하지 못할 수 있음
    - 에이징으로 해결 : 대기 시간이 길어질수록 우선순위를 점진적으로 높여주는 기법

### Multi-Level Queue

- 레디큐를 여러개의 큐로 분할하여 각 큐는 서로 다른 특성/우선순위를 가진 프로세스 그룹을 담음
- 큐마다 고정된 우선순위와 스케줄링 정책이 존재
- 큐 사이간에도 우선순위가 존재해 상위큐만 계속 실행될 수 있음 → 기아 문제

### Multi-Level Feedback Queue

- 다단계 큐 구조를 가지면서 프로세스의 실행 행동에 따라 큐를 이동 시킬 수 잇는 동적 스케줄링 방식
- 고정된 큐 구조(MLQ)와 달리 프로세스가 피드백을 통해 큐를 옮김
- 프로세스가 CPU를 오래 쓰면 우선순위를 낮추고 자주 I/O 로 빠지면 우선순위를 높게 유지

### 현대 OS는?

- 과거 OS에서는 프로세스가 실행의 기본 단위였기 때문에 CPU 스케줄링 = 프로세스 스케줄링
- 현대 운영체제는 커널 수준의 스레드를 지원하면서 하나의 프로세스 안에 여러개의 스레드가 존재할 수 있게 됨
- 따라서 대부분의 현대 OS에서는 스레드가 스케줄링의 최소단위가 됨

### 실시간 OS에서의 스케줄링

- 실시간 OS? → 정해진 시간 내에 반드시 작 업을 완료해야하는 운영체제
- soft realtime
    - 기한을 놓쳐도 시스템이 계속 동작
    - 중요한 작업은 덜 중요한 것보다 먼저 실행되도록 노력
    - 음성통화, 온라인게임 등
- hard realtime
    - 기한을 놓치면 시스템 실패
    - 모든 작업은 정해진 시간 안에 반드시 완료되어야함
    - 아주 정확하고 예측 가능한 스케줄링이 필요함
    - 로켓 ,심장 박동 조절기 등


> 참고 : 주니온님의 인프런 운영체제 공룡책 강의를 참고하였습니다.

