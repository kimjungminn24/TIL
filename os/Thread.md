## 스레드의 이해

### 스레드

- 프로세스는 컨텍스트 스위치를 통해 CPU를 번갈아 점유함
- 하나의 프로세스 안에는 여러 개의 스레드가 존재할 수 있음
- 스레드는 경량 프로세서(lightweight process)로, 프로세스와 대부분의 자원을 공유함
  - code 영역 (실행할 코드) , data 영역 (전역변수) , heap영역(동적으로 할당한 메모리)
- 각 스레드는 pc,레지스터,스택을 따로 가짐
  - pc : 현재 실행 중인 명령어 위치
  - register set : 연산에 필요한 cpu 레지스터 상태
  - stack 영역 : 함수 호출, 지역변수 저장 - 각 스레드가 자기만의 스택을 가짐

### 멀티 스레딩 장점

- responsiveness 응답성 향상 : 하나의 스레드가 대기 중이어도, 다른 스레드가 실행 가능하여 전체 응답성이 좋아짐
- resource sharing 자원 공유 : 같은 프로세스 내 스레드끼리는 메모리 공간, 파일등 자원을 공유할 수 있어 효율적
- economy 효율성 : 프로세스를 새로 생성하는 것보다 스레드를 생성하는 비용이 더 적음
- scalability 확장성 : 멀티 코어 cpu 환경에서는 스레드를 병렬로 분산 실행하여 성능 향상 가능

### 자바에서 스레드 사용법

1. Thread 클래스 상속

   - Thread 상속 받고 run() 메서드 오버라이드

   ```java
   class MyThread extends Thread {
       public void run() {
           System.out.println("Thread 실행 중");
       }
   }
   new MyThread().start();
   ```

2. Runnable 인터페이스 구현

   - Runnable을 구현해서 run 메서드 작성

   ```java
   class MyRunnable implements Runnable {
       public void run() {
           System.out.println("Runnable 실행 중");
       }
   }
   new Thread(new MyRunnable()).start();

   ```

3. 람다 표현식 사용

   - Runnable은 함수형 인터페이스로 람다로 간단하게 사용가능하다.

   ```java
   new Thread(() -> {
       System.out.println("람다 스레드 실행 중");
   }).start();
   ```

- join() : 다른 스레드가 끝날 때 까지 현재 스레드 대기
- interrupt() : 스레드에 인터럽트를 걸어 중단 신호를 보냄

### 멀티 코어

- 멀티 코어 시스템에서는 여러 스레드를 동시에 다른 코어에 배치할 수 있기 때문에 싱글 코어보다 동시성과 병렬성이 모두 향상됨
  - 여기서 동시성이란 task들이 빠르게 전환하면서 실행되어 동시에 실행되는것처럼 보이는것임
- 네개의 스레드를 고려해보면 싱클 코어는 interleaved (교차실행) 방식으로 한번에 하나씩 번갈아 실행함
  - 운영체제가 context switching을 빠르게 해서 여러 스레드가 동시에 실행되는것처럼 보이도록 동작함
- 멀티 코어에서는 각 스레드를 코어에 분산시켜 실제로 병렬적으로 실행시킬 수 잇음

### 멀티코어 환경에서의 챌린지

- Identifying task : 어떤 작업을 병렬화 할 수 있을지를 프로그래머가 직접 식별해야함
- balance : 코어마다 할 일이 균등하게 분배 되지 않으면 성능이 낭비됨
- data splitting : 데이터를 각 코어가 자기 일만 하도록 잘 나눠줘야 병렬 실행 가능
- data dependency : 병렬로 처리하던 중 여러 스레드가 같은 데이터를 수정하려고 하면 충돌 발생
- testing and debugging : 멀티코어 환경에서는 실행 순서가 매번 다를 수 있음

### 암달의 법칙

- 프로그램을 병렬화 했을 때, 최대 얼마만큼 성능 향상이 가능한지 이론적으로 계산하는 식
- SpeedUp(N) = 1 / (S + (1-S) /N)
  - N은 사용할 CPU 코어 수
  - S는 전체 작업 중 병렬화가 불가능한 부분
  - 1 - S는 병렬화가 가능한 비율
  - SpeedUp(N)는 N개의 코어를 사용했을 때 속도 향상 배율
- 전체 프로그램 중 40프로는 직렬이고 나머지 60프로는 병렬화가 가능하고 cpu코어 4개를 사용한다면?
  - SpeedUp(4) = 1 / (0.4 + (0.6/4)) = 1 /(0.55) = 약 1.8 , 최대 성능 향상은 1.8배임
- 코어는 많을 수록 좋은가?
  - 꼭 그렇지는 않음. 병렬화 가능한 부분이 적으면 코어를 많이 늘려도 성능 향상이 거의 없음
  - 암달의 법칙에 따르면, 병렬화 불가능한 부분이 클수록 속도 향상 한계가 빨리 옴
  - 병렬화 가능한 부분이란? 작업을 여러 코어에서 동시에 실행해도 결과가 같고, 서로 영향을 주지 않는 부분

### 스레드 종류

- 유저 스레드 : 커널에 직접 알려지지 않음 , 사용자 공간에서 실행됨
- 커널 스레드 : 운영체제가 직접 관리하는 스레드

### 자바에서의 스레드

- 과거 JDK 1.1 이전 : Green Thread라고 불리는 유저 스레드만 사용
- 현재는 OS위에서 동작하는 native thread 사용함
  - JVM이 OS에 따라 윈도우에서는 윈도우 스레드, 리눅스에서는 pthread을 사용함
  - 커널 스레드 기반

### 대표 스레드 라이브러리

- pthread 리눅스 환경
- 윈도우 스레드
- 자바 스레드

### Implicit Threading 암시적 스레딩

- 명시적으로 스레드를 생성하거나 제어하지 않고 컴파일러, 런타임, 프레임 워크가 내부적으로 병렬성을 자동 처리해주는 기법
- 직접 thread , runnable을 쓰면 코드가 복잡하고 오류에 취약함

1. Thread Pool (Java Executor) : Java의 ExecutorService가 내부에서 스레드를 재사용하며 병렬 작업 수행
2. Fork/Join Framework : Java 7의 ForkJoinPool을 사용하여 큰 작업을 재귀적으로 쪼개고 병렬 실행
3. OpenMp : C/C++에서 사용하는 병렬 처리 라이브러리, 컴파일러가 병렬 처리 자동화
4. Grand Central Dispatch : 맥 OS에서 사용하는 병렬 기반 스레드 관리 라이브러리

> 참고 : 주니온님의 인프런 운영체제 공룡책 강의를 참고하였습니다.
